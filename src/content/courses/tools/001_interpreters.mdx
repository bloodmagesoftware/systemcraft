---
title: Interpreter
description: An introduction to compilers and interpreters
authors:
  - frank_mayer
slug: tools/interpreters
---

## Compiler vs. Interpreter

Most compilers and interpreters are very similar.

The main difference is that compilers take code in a source format and generate code in a target format.
A C compiler for example takes C code and generates machine code that can be executed by a CPU.
A compiler does **not** need to be installed on the computer that wants to run the code.

An interpreter on the other hand takes code in a source format and executes it.
One example would be Python, which is a interpreted programming language.
Interpreters need to be installed on the computer that wants to run the code.

There are also hybrid approaches like [Just-in-time compilation](https://en.wikipedia.org/wiki/Just-in-time_compilation) (short JIT).
Those are interpreters (need to be installed) that compile parts of the source code piece by piece as it is executed.
Those compiled pieces are then stored and executed.
When a piece is already compiled, it can be executed without compiling it again.

We will go into more detail about the different compilers later.
For now, it is enough to know that there are multiple ways of running code.
We will focus on interpreters for now.

## How to read source code?

The first thing every kind of compiler/interpreter does is to read the source code.
There are two main ways of doing this:

- Abstract Syntax Tree (AST)
- Sea of Nodes

The Sea of Nodes is a more advanced way we will cover in a later chapter.

The AST approach is slower but easier to understand and more versatile.
This method has two parts:

### Lexical Analysis / Tokenization

This is just a fancy name for taking a long list of characters and grouping them together.

The source code is a list of characters.
To group those characters together, we need to define a set of rules, how groups are formed.

Most programming languages split by whitespace (space, tab, newline, etc.).
Let's take a look at this with a simple example for Math:

import LexerVisualization from "../../../components/preact/lexer-visualization.tsx";

We can build tokens while reading the source code.
When we encounter a number, we append it to the current token.
When we encounter a space, we store the token we built so far and start a new one.

<LexerVisualization
    client:load
	input="4 - 7 + 3 * 14"
	steps={[
		{ currentIndex: -1, currentChar: "", tokens: [], currentToken: "" },
		{ currentIndex: 0, currentChar: "4", tokens: [], currentToken: "4" },
		{
			currentIndex: 1,
			currentChar: " ",
			tokens: [{ type: "NUMBER", value: "4" }],
			currentToken: "",
		},
        {
			currentIndex: 2,
			currentChar: "-",
			tokens: [{ type: "NUMBER", value: "4" }],
			currentToken: "-",
		},
        {
			currentIndex: 3,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
			],
			currentToken: "",
		},
        {
			currentIndex: 4,
			currentChar: "7",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
			],
			currentToken: "7",
		},
        {
			currentIndex: 5,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
			],
			currentToken: "",
		},
        {
			currentIndex: 6,
			currentChar: "+",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
			],
			currentToken: "+",
		},
        {
			currentIndex: 7,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
			],
			currentToken: "",
		},
        {
			currentIndex: 8,
			currentChar: "3",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
			],
			currentToken: "3",
		},
        {
			currentIndex: 9,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
			],
			currentToken: "",
		},
        {
			currentIndex: 10,
			currentChar: "*",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
			],
			currentToken: "*",
		},
        {
			currentIndex: 11,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
                { type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
			],
			currentToken: "",
		},
        {
			currentIndex: 12,
			currentChar: "1",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
                { type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
			],
			currentToken: "1",
		},
        {
			currentIndex: 13,
			currentChar: "4",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
                { type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
			],
			currentToken: "14",
		},
        {
			currentIndex: 14,
			currentChar: null,
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
                { type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
				{ type: "NUMBER", value: "14" },
			],
			currentToken: "",
            },
        ]}
/>

The "split by space" rule works for this case, because there is a space between each token.
But it's not always like this.
Someone might write the same expression like this: `4 - 7+ 3 *14`.

In this case, we would get wrong tokens: `4`, `-`, `7+`, `3`, `*14`.
This makes no sense, right?

For us humans, it's easy to understand the expression, even though it's not formatted well.
We know that a operator like `*` can never be part of a number.
We need to teach our lexer to do the same.

We need to split when we encounter a space, but also when we encounter a operator.

<LexerVisualization
    client:load
	input="4 - 7+ 3 *14"
	steps={[
		{ currentIndex: -1, currentChar: "", tokens: [], currentToken: "" },
		{ currentIndex: 0, currentChar: "4", tokens: [], currentToken: "4" },
		{
			currentIndex: 1,
			currentChar: " ",
			tokens: [{ type: "NUMBER", value: "4" }],
			currentToken: "",
		},
		{
			currentIndex: 2,
			currentChar: "-",
			tokens: [{ type: "NUMBER", value: "4" }],
			currentToken: "-",
		},
		{
			currentIndex: 3,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
			],
			currentToken: "",
		},
		{
			currentIndex: 4,
			currentChar: "7",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
			],
			currentToken: "7",
		},
		{
			currentIndex: 5,
			currentChar: "+",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
			],
			currentToken: "+",
		},
		{
			currentIndex: 6,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
			],
			currentToken: "",
		},
		{
			currentIndex: 7,
			currentChar: "3",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
			],
			currentToken: "3",
		},
		{
			currentIndex: 8,
			currentChar: " ",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
			],
			currentToken: "",
		},
		{
			currentIndex: 9,
			currentChar: "*",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
			],
			currentToken: "*",
		},
		{
			currentIndex: 10,
			currentChar: "1",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
			],
			currentToken: "1",
		},
		{
			currentIndex: 11,
			currentChar: "4",
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
			],
			currentToken: "14",
		},
		{
			currentIndex: 12,
			currentChar: null,
			tokens: [
				{ type: "NUMBER", value: "4" },
				{ type: "OPERATOR", value: "-" },
				{ type: "NUMBER", value: "7" },
				{ type: "OPERATOR", value: "+" },
				{ type: "NUMBER", value: "3" },
				{ type: "OPERATOR", value: "*" },
				{ type: "NUMBER", value: "14" },
			],
			currentToken: "",
		},
	]}
/>
